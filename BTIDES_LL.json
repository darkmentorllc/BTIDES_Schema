{
  "$id": "https://darkmentor.com/BTIDES_Schema/BTIDES_LL.json",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "description": "JSON Schema for Bluetooth Device Information. Sub-information, Link Layer packet information data types",
  "type": "object",
  "properties": {
    "LLArray": {
      "type": "array",
      "items": {
        "anyOf": [
          {
            "$ref": "#/definitions/LL_CONNECTION_UPDATE_IND"
          },
          {
            "$ref": "#/definitions/LL_CONNECTION_UPDATE_IND2"
          },
          {
            "$ref": "#/definitions/LL_CHANNEL_MAP_IND"
          },
          {
            "$ref": "#/definitions/LL_CHANNEL_MAP_IND2"
          },
          {
            "$ref": "#/definitions/LL_TERMINATE_IND"
          },
          {
            "$ref": "#/definitions/LL_TERMINATE_IND2"
          },
          {
            "$ref": "#/definitions/LL_ENC_REQ"
          },
          {
            "$ref": "#/definitions/LL_ENC_REQ2"
          },
          {
            "$ref": "#/definitions/LL_ENC_RSP"
          },
          {
            "$ref": "#/definitions/LL_ENC_RSP2"
          },
          {
            "$ref": "#/definitions/LL_UNKNOWN_RSP"
          },
          {
            "$ref": "#/definitions/LL_UNKNOWN_RSP2"
          },
          {
            "$ref": "#/definitions/LL_FEATURE_REQ"
          },
          {
            "$ref": "#/definitions/LL_FEATURE_REQ2"
          },
          {
            "$ref": "#/definitions/LL_FEATURE_RSP"
          },
          {
            "$ref": "#/definitions/LL_FEATURE_RSP2"
          },
          {
            "$ref": "#/definitions/LL_VERSION_IND"
          },
          {
            "$ref": "#/definitions/LL_VERSION_IND2"
          },
          {
            "$ref": "#/definitions/LL_PERIPHERAL_FEATURE_REQ"
          },
          {
            "$ref": "#/definitions/LL_PERIPHERAL_FEATURE_REQ2"
          },
          {
            "$ref": "#/definitions/LL_CONNECTION_PARAM_REQ"
          },
          {
            "$ref": "#/definitions/LL_CONNECTION_PARAM_REQ2"
          },
          {
            "$ref": "#/definitions/LL_CONNECTION_PARAM_RSP"
          },
          {
            "$ref": "#/definitions/LL_CONNECTION_PARAM_RSP2"
          },
          {
            "$ref": "#/definitions/LL_PING_REQ"
          },
          {
            "$ref": "#/definitions/LL_PING_RSP"
          },
          {
            "$ref": "#/definitions/LL_LENGTH_REQ"
          },
          {
            "$ref": "#/definitions/LL_LENGTH_REQ2"
          },
          {
            "$ref": "#/definitions/LL_LENGTH_RSP"
          },
          {
            "$ref": "#/definitions/LL_LENGTH_RSP2"
          },
          {
            "$ref": "#/definitions/LL_PHY_REQ"
          },
          {
            "$ref": "#/definitions/LL_PHY_REQ2"
          },
          {
            "$ref": "#/definitions/LL_PHY_RSP"
          },
          {
            "$ref": "#/definitions/LL_PHY_RSP2"
          }
        ]
      }
    }
  },
  "definitions": {
    "LL_CONNECTION_UPDATE_IND": {
      "type": "object",
      "description": "Structure for LL\\_CONNECTION\\_UPDATE\\_IND packet.",
      "required": [
        "direction",
        "opcode",
        "win_size",
        "win_offset",
        "interval",
        "latency",
        "timeout",
        "instant"
      ],
      "properties": {
        "std_optional_fields": {
          "$ref": "BTIDES_base.json#/definitions/std_optional_fields"
        },
        "direction": {
          "$ref": "BTIDES_base.json#/definitions/direction"
        },
        "opcode_str": {
          "description": "This optional field is just for if you don't care about json file size and you want more human-readable JSON output.",
          "type": "string",
          "const": "LL_CONNECTION_UPDATE_IND"
        },
        "opcode": {
          "description": "This should always be 0. This is required to differentiate from other data types in an array.",
          "const": 0
        },
        "win_size": {
          "description": "The transmit window size used in the CONNECT_IND packet. (Multiplied by 1.25ms). This should technically be only between 1 and 255, but put in whatever was actually used (i.e. accept 0).",
          "type": "integer",
          "minimum": 0,
          "maximum": 255
        },
        "win_offset": {
          "description": "The transmit window offset used in the CONNECT_IND packet. (Multiplied by 1.25ms). \"The transmitWindowOffset shall be a multiple of 1.25 ms in the range 0 ms to connInterval.\" according to the spec.",
          "type": "integer",
          "minimum": 0,
          "maximum": 65535
        },
        "interval": {
          "description": "The connection interval used in the CONNECT_IND packet. (Multiplied by 1.25ms). This should technically be only between 7.5ms to 4.0s (6-3200) according to the spec, but put in whatever was actually used.",
          "type": "integer",
          "minimum": 0,
          "maximum": 65535
        },
        "latency": {
          "description": "The Peripheral latency used in the CONNECT_IND packet. \"The value of connSubrateFactor shall be in the range 1 to 500 and shall be set to 1 for a new connection\" to be valid according to the spec, but put whatever value was actually found in the packet.",
          "type": "integer",
          "minimum": 0,
          "maximum": 65535
        },
        "timeout": {
          "description": "The connection timeout used in the CONNECT_IND packet. (Multiplied by 10ms). \"The connSupervisionTimeout shall be a multiple of 10 ms in the range 100 ms to 32.0s and it shall be larger than (1 + connPeripheralLatency) × connSubrateFactor × connInterval × 2.\" (so 1-3200)according to the spec, but put in whatever was actually used.",
          "type": "integer",
          "minimum": 0,
          "maximum": 65535
        },
        "instant": {
          "description": "What instant (connection event from start of connection, indexed from 0) the update will occur at.",
          "type": "integer",
          "minimum": 0,
          "maximum": 65535
        }
      }
    },
    "LL_CONNECTION_UPDATE_IND2": {
      "type": "object",
      "description": "Structure for LL\\_CONNECTION\\_UPDATE\\_IND packet.",
      "required": [
        "direction",
        "opcode",
        "full_pkt_hex_str"
      ],
      "properties": {
        "std_optional_fields": {
          "$ref": "BTIDES_base.json#/definitions/std_optional_fields"
        },
        "direction": {
          "$ref": "BTIDES_base.json#/definitions/direction"
        },
        "opcode_str": {
          "description": "This optional field is just for if you don't care about json file size and you want more human-readable JSON output.",
          "type": "string",
          "const": "LL_CONNECTION_UPDATE_IND"
        },
        "opcode": {
          "description": "This should always be 0. This is required to differentiate from other data types in an array.",
          "const": 0
        },
        "full_pkt_hex_str": {
          "$ref": "BTIDES_base.json#/definitions/full_pkt_hex_str"
        }
      }
    },
    "LL_CHANNEL_MAP_IND": {
      "type": "object",
      "description": "Structure for LL\\_CHANNEL\\_MAP\\_IND packet.",
      "required": [
        "direction",
        "opcode",
        "channel_map_hex_str",
        "instant"
      ],
      "properties": {
        "std_optional_fields": {
          "$ref": "BTIDES_base.json#/definitions/std_optional_fields"
        },
        "direction": {
          "$ref": "BTIDES_base.json#/definitions/direction"
        },
        "opcode_str": {
          "description": "This optional field is just for if you don't care about json file size and you want more human-readable JSON output.",
          "type": "string",
          "const": "LL_CHANNEL_MAP_IND"
        },
        "opcode": {
          "description": "This should always be 1. This is required to differentiate from other data types in an array.",
          "const": 1
        },
        "channel_map_hex_str": {
          "description": "The (5-byte) channel map used in the CONNECT_IND packet, as a hex string.",
          "type": "string",
          "minLength": 10,
          "maxLength": 10
        },
        "instant": {
          "description": "What instant (connection event from start of connection, indexed from 0) the update will occur at.",
          "type": "integer",
          "minimum": 0,
          "maximum": 65535
        }
      }
    },
    "LL_CHANNEL_MAP_IND2": {
      "type": "object",
      "description": "Structure for LL\\_CHANNEL\\_MAP\\_IND packet.",
      "required": [
        "direction",
        "opcode",
        "full_pkt_hex_str"
      ],
      "properties": {
        "std_optional_fields": {
          "$ref": "BTIDES_base.json#/definitions/std_optional_fields"
        },
        "direction": {
          "$ref": "BTIDES_base.json#/definitions/direction"
        },
        "opcode_str": {
          "description": "This optional field is just for if you don't care about json file size and you want more human-readable JSON output.",
          "type": "string",
          "const": "LL_CHANNEL_MAP_IND"
        },
        "opcode": {
          "description": "This should always be 1. This is required to differentiate from other data types in an array.",
          "const": 1
        },
        "full_pkt_hex_str": {
          "$ref": "BTIDES_base.json#/definitions/full_pkt_hex_str"
        }
      }
    },
    "LL_TERMINATE_IND": {
      "type": "object",
      "description": "Structure for LL\\_TERMINATE\\_IND packet.",
      "required": [
        "direction",
        "opcode",
        "error_code"
      ],
      "properties": {
        "std_optional_fields": {
          "$ref": "BTIDES_base.json#/definitions/std_optional_fields"
        },
        "direction": {
          "$ref": "BTIDES_base.json#/definitions/direction"
        },
        "error_str": {
          "description": "Optional human-readable string describing the error.",
          "type": "string"
        },
        "opcode_str": {
          "description": "This optional field is just for if you don't care about json file size and you want more human-readable JSON output.",
          "type": "string",
          "const": "LL_TERMINATE_IND"
        },
        "opcode": {
          "description": "This should always be 2. This is required to differentiate from other data types in an array.",
          "const": 2
        },
        "error_code": {
          "description": "One byte value indicating the reason for termination.",
          "type": "integer",
          "minimum": 0,
          "maximum": 255
        }
      }
    },
    "LL_TERMINATE_IND2": {
      "type": "object",
      "description": "Structure for LL\\_TERMINATE\\_IND packet, as single raw hex string.",
      "required": [
        "direction",
        "opcode",
        "full_pkt_hex_str"
      ],
      "properties": {
        "std_optional_fields": {
          "$ref": "BTIDES_base.json#/definitions/std_optional_fields"
        },
        "direction": {
          "$ref": "BTIDES_base.json#/definitions/direction"
        },
        "opcode_str": {
          "description": "This optional field is just for if you don't care about json file size and you want more human-readable JSON output.",
          "type": "string",
          "const": "LL_TERMINATE_IND"
        },
        "opcode": {
          "description": "This should always be 2. This is required to differentiate from other data types in an array.",
          "const": 2
        },
        "full_pkt_hex_str": {
          "$ref": "BTIDES_base.json#/definitions/full_pkt_hex_str"
        }
      }
    },
    "LL_ENC_REQ": {
      "type": "object",
      "description": "Structure for LL\\_ENC\\_REQ packet.",
      "required": [
        "direction",
        "opcode",
        "rand",
        "ediv",
        "skd_c",
        "iv_c"
      ],
      "properties": {
        "std_optional_fields": {
          "$ref": "BTIDES_base.json#/definitions/std_optional_fields"
        },
        "direction": {
          "$ref": "BTIDES_base.json#/definitions/direction"
        },
        "opcode_str": {
          "description": "This optional field is just for if you don't care about json file size and you want more human-readable JSON output.",
          "type": "string",
          "const": "LL_ENC_REQ"
        },
        "opcode": {
          "description": "This should always be 3. This is required to differentiate from other data types in an array.",
          "const": 3
        },
        "rand": {
          "description": "8 byte random value provided by host.",
          "type": "integer",
          "minimum": 0,
          "maximum": 18446744073709551615
        },
        "ediv": {
          "description": "2 byte encrypted diversifier.",
          "type": "integer",
          "minimum": 0,
          "maximum": 65535
        },
        "skd_c": {
          "description": "8 byte session key diversifier from Central.",
          "type": "integer",
          "minimum": 0,
          "maximum": 18446744073709551615
        },
        "iv_c": {
          "description": "4 byte initialization vector from Central.",
          "type": "integer",
          "minimum": 0,
          "maximum": 4294967295
        }
      }
    },
    "LL_ENC_REQ2": {
      "type": "object",
      "description": "Structure for LL\\_ENC\\_REQ packet.",
      "required": [
        "direction",
        "opcode",
        "full_pkt_hex_str"
      ],
      "properties": {
        "std_optional_fields": {
          "$ref": "BTIDES_base.json#/definitions/std_optional_fields"
        },
        "direction": {
          "$ref": "BTIDES_base.json#/definitions/direction"
        },
        "opcode_str": {
          "description": "This optional field is just for if you don't care about json file size and you want more human-readable JSON output.",
          "type": "string",
          "const": "LL_ENC_REQ"
        },
        "opcode": {
          "description": "This should always be 3. This is required to differentiate from other data types in an array.",
          "const": 3
        },
        "full_pkt_hex_str": {
          "$ref": "BTIDES_base.json#/definitions/full_pkt_hex_str"
        }
      }
    },
    "LL_ENC_RSP": {
      "type": "object",
      "description": "Structure for LL\\_ENC\\_RSP packet.",
      "required": [
        "direction",
        "opcode",
        "skd_p",
        "iv_p"
      ],
      "properties": {
        "std_optional_fields": {
          "$ref": "BTIDES_base.json#/definitions/std_optional_fields"
        },
        "direction": {
          "$ref": "BTIDES_base.json#/definitions/direction"
        },
        "opcode_str": {
          "description": "This optional field is just for if you don't care about json file size and you want more human-readable JSON output.",
          "type": "string",
          "const": "LL_ENC_RSP"
        },
        "opcode": {
          "description": "This should always be 4. This is required to differentiate from other data types in an array.",
          "const": 4
        },
        "skd_p": {
          "description": "8 byte session key diversifier from Perpheral.",
          "type": "integer",
          "minimum": 0,
          "maximum": 18446744073709551615
        },
        "iv_p": {
          "description": "4 byte initialization vector from Perpheral.",
          "type": "integer",
          "minimum": 0,
          "maximum": 4294967295
        }
      }
    },
    "LL_ENC_RSP2": {
      "type": "object",
      "description": "Structure for LL\\_ENC\\_RSP packet.",
      "required": [
        "direction",
        "opcode",
        "full_pkt_hex_str"
      ],
      "properties": {
        "std_optional_fields": {
          "$ref": "BTIDES_base.json#/definitions/std_optional_fields"
        },
        "direction": {
          "$ref": "BTIDES_base.json#/definitions/direction"
        },
        "opcode_str": {
          "description": "This optional field is just for if you don't care about json file size and you want more human-readable JSON output.",
          "type": "string",
          "const": "LL_ENC_RSP"
        },
        "opcode": {
          "description": "This should always be 4. This is required to differentiate from other data types in an array.",
          "const": 4
        },
        "full_pkt_hex_str": {
          "$ref": "BTIDES_base.json#/definitions/full_pkt_hex_str"
        }
      }
    },
    "LL_UNKNOWN_RSP": {
      "type": "object",
      "description": "Structure for LL\\_UNKNOWN\\_RSP packet.",
      "required": [
        "direction",
        "opcode",
        "unknown_type"
      ],
      "properties": {
        "std_optional_fields": {
          "$ref": "BTIDES_base.json#/definitions/std_optional_fields"
        },
        "direction": {
          "$ref": "BTIDES_base.json#/definitions/direction"
        },
        "opcode_str": {
          "description": "This optional field is just for if you don't care about json file size and you want more human-readable JSON output.",
          "type": "string",
          "const": "LL_UNKNOWN_RSP"
        },
        "opcode": {
          "description": "This should always be 7. This is required to differentiate from other data types in an array.",
          "const": 7
        },
        "unknown_type": {
          "description": "One byte value indicating the LL opcode of a message received that the device does not understand.",
          "type": "integer",
          "minimum": 0,
          "maximum": 255
        }
      }
    },
    "LL_UNKNOWN_RSP2": {
      "type": "object",
      "description": "Structure for LL\\_UNKNOWN\\_RSP packet, as single raw hex string.",
      "required": [
        "direction",
        "opcode",
        "full_pkt_hex_str"
      ],
      "properties": {
        "std_optional_fields": {
          "$ref": "BTIDES_base.json#/definitions/std_optional_fields"
        },
        "direction": {
          "$ref": "BTIDES_base.json#/definitions/direction"
        },
        "opcode_str": {
          "description": "This optional field is just for if you don't care about json file size and you want more human-readable JSON output.",
          "type": "string",
          "const": "LL_UNKNOWN_RSP"
        },
        "opcode": {
          "description": "This should always be 7. This is required to differentiate from other data types in an array.",
          "const": 7
        },
        "full_pkt_hex_str": {
          "$ref": "BTIDES_base.json#/definitions/full_pkt_hex_str"
        }
      }
    },
    "le_features_hex_str": {
      "description": "An bit-array of LE supported features, 8 bytes long, defined in spec section \"Feature Support\" under Link Layer specification. Used by LL\\_FEATURE\\_REQ/RSP and as an optional AdvData type.",
      "type": "string",
      "minLength": 16,
      "maxLength": 16
    },
    "LL_FEATURE_REQ": {
      "type": "object",
      "description": "Structure for LL\\_FEATURE\\_REQ packet.",
      "required": [
        "direction",
        "opcode",
        "le_features_hex_str"
      ],
      "properties": {
        "std_optional_fields": {
          "$ref": "BTIDES_base.json#/definitions/std_optional_fields"
        },
        "direction": {
          "$ref": "BTIDES_base.json#/definitions/direction"
        },
        "opcode_str": {
          "description": "This optional field is just for if you don't care about json file size and you want more human-readable JSON output.",
          "type": "string",
          "const": "LL_FEATURE_REQ"
        },
        "opcode": {
          "description": "This should always be 8. This is required to differentiate from other data types in an array.",
          "const": 8
        },
        "le_features_hex_str": {
          "$ref": "#/definitions/le_features_hex_str"
        }
      }
    },
    "LL_FEATURE_REQ2": {
      "type": "object",
      "description": "Structure for LL\\_FEATURE\\_REQ packet, as single raw hex string.",
      "required": [
        "direction",
        "opcode",
        "full_pkt_hex_str"
      ],
      "properties": {
        "std_optional_fields": {
          "$ref": "BTIDES_base.json#/definitions/std_optional_fields"
        },
        "direction": {
          "$ref": "BTIDES_base.json#/definitions/direction"
        },
        "opcode_str": {
          "description": "This optional field is just for if you don't care about json file size and you want more human-readable JSON output.",
          "type": "string",
          "const": "LL_FEATURE_REQ"
        },
        "opcode": {
          "description": "This should always be 8. This is required to differentiate from other data types in an array.",
          "const": 8
        },
        "full_pkt_hex_str": {
          "$ref": "BTIDES_base.json#/definitions/full_pkt_hex_str"
        }
      }
    },
    "LL_FEATURE_RSP": {
      "type": "object",
      "description": "Structure for LL\\_FEATURE\\_RSP packet.",
      "required": [
        "direction",
        "opcode",
        "le_features_hex_str"
      ],
      "properties": {
        "std_optional_fields": {
          "$ref": "BTIDES_base.json#/definitions/std_optional_fields"
        },
        "direction": {
          "$ref": "BTIDES_base.json#/definitions/direction"
        },
        "opcode_str": {
          "description": "This optional field is just for if you don't care about json file size and you want more human-readable JSON output.",
          "type": "string",
          "const": "LL_FEATURE_RSP"
        },
        "opcode": {
          "description": "This should always be 9. This is required to differentiate from other data types in an array.",
          "const": 9
        },
        "le_features_hex_str": {
          "$ref": "#/definitions/le_features_hex_str"
        }
      }
    },
    "LL_FEATURE_RSP2": {
      "type": "object",
      "description": "Structure for LL\\_FEATURE\\_RSP packet, as single raw hex string.",
      "required": [
        "direction",
        "opcode",
        "full_pkt_hex_str"
      ],
      "properties": {
        "std_optional_fields": {
          "$ref": "BTIDES_base.json#/definitions/std_optional_fields"
        },
        "direction": {
          "$ref": "BTIDES_base.json#/definitions/direction"
        },
        "opcode_str": {
          "description": "This optional field is just for if you don't care about json file size and you want more human-readable JSON output.",
          "type": "string",
          "const": "LL_FEATURE_RSP"
        },
        "opcode": {
          "description": "This should always be 9. This is required to differentiate from other data types in an array.",
          "const": 9
        },
        "full_pkt_hex_str": {
          "$ref": "BTIDES_base.json#/definitions/full_pkt_hex_str"
        }
      }
    },
    "LL_VERSION_IND": {
      "type": "object",
      "description": "Structure for LL\\_VERSION\\_IND packet.",
      "required": [
        "direction",
        "opcode",
        "version",
        "company_id",
        "subversion"
      ],
      "$comment": "I'm only putting these version/company_id/subversion up to the top level definitions so I can reference them from LMP as well, since they're the same meaning/values.",
      "properties": {
        "std_optional_fields": {
          "$ref": "BTIDES_base.json#/definitions/std_optional_fields"
        },
        "opcode_str": {
          "description": "This optional field is just for if you don't care about json file size and you want more human-readable JSON output.",
          "type": "string",
          "const": "LL_VERSION_IND"
        },
        "direction": {
          "$ref": "BTIDES_base.json#/definitions/direction"
        },
        "opcode": {
          "description": "This should always be 12. This is required to differentiate from other data types in an array.",
          "const": 12
        },
        "version": {
          "$ref": "#/definitions/version"
        },
        "company_id": {
          "$ref": "#/definitions/company_id"
        },
        "subversion": {
          "$ref": "#/definitions/subversion"
        }
      }
    },
    "version": {
      "description": "One byte value indicating version of the BT Core Specification that this device comforms to.\n e.g. 0x06 = 4.0, 0x08 = 4.2, 0x09 = 5.0, 0x0D = 5.4 etc. See Assigned Numbers document. \n Only setting an upper bound to enforce sanity checking that this is a single byte value.",
      "type": "integer",
      "minimum": 0,
      "maximum": 255
    },
    "company_id": {
      "description": "Company ID as assigned by Bluetooth SIG. See assigned\\_numbers/company\\_identifiers/company\\_identifiers.yaml from https://bitbucket.org/bluetooth-SIG/public. \n Only setting an upper bound to enforce sanity checking that this is a two-byte value.",
      "type": "integer",
      "minimum": 0,
      "maximum": 65535
    },
    "subversion": {
      "description": "This is nominally the sub-version of the BT controller itself (i.e. hardware). This value is arbitrary, and picked by the hardware maker. \n The correspondance of certain values to certain hardware is known for some vendors like Broadcom, but is unknown for most vendors.\n Only setting an upper bound to enforce sanity checking that this is a two-byte value.",
      "type": "integer",
      "minimum": 0,
      "maximum": 65535
    },
    "LL_VERSION_IND2": {
      "type": "object",
      "description": "Structure for LL\\_VERSION\\_IND packet, as single raw hex string.",
      "required": [
        "direction",
        "opcode",
        "full_pkt_hex_str"
      ],
      "properties": {
        "std_optional_fields": {
          "$ref": "BTIDES_base.json#/definitions/std_optional_fields"
        },
        "direction": {
          "$ref": "BTIDES_base.json#/definitions/direction"
        },
        "opcode": {
          "description": "This should always be 12. This is required to differentiate from other data types in an array.",
          "const": 12
        },
        "full_pkt_hex_str": {
          "$ref": "BTIDES_base.json#/definitions/full_pkt_hex_str"
        }
      }
    },
    "LL_PERIPHERAL_FEATURE_REQ": {
      "type": "object",
      "description": "Structure for LL\\_PERIPHERAL\\_FEATURE\\_REQ packet.",
      "required": [
        "direction",
        "opcode",
        "le_features_hex_str"
      ],
      "properties": {
        "std_optional_fields": {
          "$ref": "BTIDES_base.json#/definitions/std_optional_fields"
        },
        "direction": {
          "$ref": "BTIDES_base.json#/definitions/direction"
        },
        "opcode_str": {
          "description": "This optional field is just for if you don't care about json file size and you want more human-readable JSON output.",
          "type": "string",
          "const": "LL_PERIPHERAL_FEATURE_REQ"
        },
        "opcode": {
          "description": "This should always be 14. This is required to differentiate from other data types in an array.",
          "const": 14
        },
        "le_features_hex_str": {
          "$ref": "#/definitions/le_features_hex_str"
        }
      }
    },
    "LL_PERIPHERAL_FEATURE_REQ2": {
      "type": "object",
      "description": "Structure for LL\\_PERIPHERAL\\_FEATURE\\_REQ packet, as single raw hex string.",
      "required": [
        "direction",
        "opcode",
        "full_pkt_hex_str"
      ],
      "properties": {
        "std_optional_fields": {
          "$ref": "BTIDES_base.json#/definitions/std_optional_fields"
        },
        "direction": {
          "$ref": "BTIDES_base.json#/definitions/direction"
        },
        "opcode_str": {
          "description": "This optional field is just for if you don't care about json file size and you want more human-readable JSON output.",
          "type": "string",
          "const": "LL_PERIPHERAL_FEATURE_REQ"
        },
        "opcode": {
          "description": "This should always be 14. This is required to differentiate from other data types in an array.",
          "const": 14
        },
        "full_pkt_hex_str": {
          "$ref": "BTIDES_base.json#/definitions/full_pkt_hex_str"
        }
      }
    },
    "LL_CONNECTION_PARAM_REQ": {
      "type": "object",
      "description": "Structure for LL\\_CONNECTION\\_PARAM\\_REQ packet.",
      "required": [
        "direction",
        "opcode",
        "interval_min",
        "interval_max",
        "latency",
        "timeout",
        "preferred_periodicity",
        "reference_conneventcount",
        "offset0",
        "offset1",
        "offset2",
        "offset3",
        "offset4",
        "offset5"
      ],
      "properties": {
        "std_optional_fields": {
          "$ref": "BTIDES_base.json#/definitions/std_optional_fields"
        },
        "direction": {
          "$ref": "BTIDES_base.json#/definitions/direction"
        },
        "opcode_str": {
          "description": "This optional field is just for if you don't care about json file size and you want more human-readable JSON output.",
          "type": "string",
          "const": "LL_CONNECTION_PARAM_REQ"
        },
        "opcode": {
          "description": "This should always be 15. This is required to differentiate from other data types in an array.",
          "const": 15
        },
        "interval_min": {
          "description": "The minimum connection interval. (Multiplied by 1.25ms). This should technically be only between 7.5ms to 4.0s (6-3200) according to the spec, but put in whatever was actually used.",
          "type": "integer",
          "minimum": 0,
          "maximum": 65535
        },
        "interval_max": {
          "description": "The maximum connection interval. (Multiplied by 1.25ms). This should technically be only between 7.5ms to 4.0s (6-3200) according to the spec, but put in whatever was actually used.",
          "type": "integer",
          "minimum": 0,
          "maximum": 65535
        },
        "latency": {
          "description": "The Peripheral latency (how many connection events the Peripheral can skip replying to.). \"The value of connSubrateFactor shall be in the range 1 to 500 and shall be set to 1 for a new connection\" to be valid according to the spec, but put whatever value was actually found in the packet.",
          "type": "integer",
          "minimum": 0,
          "maximum": 65535
        },
        "timeout": {
          "description": "The connection timeout. (Multiplied by 10ms). \"The connSupervisionTimeout shall be a multiple of 10 ms in the range 100 ms to 32.0s and it shall be larger than (1 + connPeripheralLatency) × connSubrateFactor × connInterval × 2.\" (so 1-3200)according to the spec, but put in whatever was actually used.",
          "type": "integer",
          "minimum": 0,
          "maximum": 65535
        },
        "preferred_periodicity": {
          "description": "Multiplied by 1.25ms. 'The PreferredPeriodicity field shall be set to indicate a value the connInterval is preferred to be a multiple of.'",
          "type": "integer",
          "minimum": 0,
          "maximum": 255
        },
        "reference_conneventcount": {
          "description": "'The ReferenceConnEventCount field shall be set to indicate the value of the connEventCounter relative to which all the valid Offset0 to Offset5 fields have been calculated.'",
          "type": "integer",
          "minimum": 0,
          "maximum": 65535
        },
        "offset0": {
          "description": "'The Offset0, Offset1, Offset2, Offset3, Offset4, and Offset5 fields shall be set to indicate the possible values of the position of the anchor points of the LE connection with the updated connection parameters relative to the ReferenceConnEventCount.' + 'A value of 0xFFFF means not valid.'",
          "type": "integer",
          "minimum": 0,
          "maximum": 65535
        },
        "offset1": {
          "description": "'The Offset0, Offset1, Offset2, Offset3, Offset4, and Offset5 fields shall be set to indicate the possible values of the position of the anchor points of the LE connection with the updated connection parameters relative to the ReferenceConnEventCount.' + 'A value of 0xFFFF means not valid.'",
          "type": "integer",
          "minimum": 0,
          "maximum": 65535
        },
        "offset2": {
          "description": "'The Offset0, Offset1, Offset2, Offset3, Offset4, and Offset5 fields shall be set to indicate the possible values of the position of the anchor points of the LE connection with the updated connection parameters relative to the ReferenceConnEventCount.' + 'A value of 0xFFFF means not valid.'",
          "type": "integer",
          "minimum": 0,
          "maximum": 65535
        },
        "offset3": {
          "description": "'The Offset0, Offset1, Offset2, Offset3, Offset4, and Offset5 fields shall be set to indicate the possible values of the position of the anchor points of the LE connection with the updated connection parameters relative to the ReferenceConnEventCount.' + 'A value of 0xFFFF means not valid.'",
          "type": "integer",
          "minimum": 0,
          "maximum": 65535
        },
        "offset4": {
          "description": "'The Offset0, Offset1, Offset2, Offset3, Offset4, and Offset5 fields shall be set to indicate the possible values of the position of the anchor points of the LE connection with the updated connection parameters relative to the ReferenceConnEventCount.' + 'A value of 0xFFFF means not valid.'",
          "type": "integer",
          "minimum": 0,
          "maximum": 65535
        },
        "offset5": {
          "description": "'The Offset0, Offset1, Offset2, Offset3, Offset4, and Offset5 fields shall be set to indicate the possible values of the position of the anchor points of the LE connection with the updated connection parameters relative to the ReferenceConnEventCount.' + 'A value of 0xFFFF means not valid.'",
          "type": "integer",
          "minimum": 0,
          "maximum": 65535
        }
      }
    },
    "LL_CONNECTION_PARAM_REQ2": {
      "type": "object",
      "description": "Structure for LL\\_CONNECTION\\_PARAM\\_REQ packet.",
      "required": [
        "direction",
        "opcode",
        "full_pkt_hex_str"
      ],
      "properties": {
        "std_optional_fields": {
          "$ref": "BTIDES_base.json#/definitions/std_optional_fields"
        },
        "direction": {
          "$ref": "BTIDES_base.json#/definitions/direction"
        },
        "opcode_str": {
          "description": "This optional field is just for if you don't care about json file size and you want more human-readable JSON output.",
          "type": "string",
          "const": "LL_PERIPHERAL_FEATURE_REQ"
        },
        "opcode": {
          "description": "This should always be 15. This is required to differentiate from other data types in an array.",
          "const": 15
        },
        "full_pkt_hex_str": {
          "$ref": "BTIDES_base.json#/definitions/full_pkt_hex_str"
        }
      }
    },
    "LL_CONNECTION_PARAM_RSP": {
      "type": "object",
      "description": "Structure for LL\\_CONNECTION\\_PARAM\\_RSP packet.",
      "required": [
        "direction",
        "opcode",
        "interval_min",
        "interval_max",
        "latency",
        "timeout",
        "preferred_periodicity",
        "reference_conneventcount",
        "offset0",
        "offset1",
        "offset2",
        "offset3",
        "offset4",
        "offset5"
      ],
      "properties": {
        "std_optional_fields": {
          "$ref": "BTIDES_base.json#/definitions/std_optional_fields"
        },
        "direction": {
          "$ref": "BTIDES_base.json#/definitions/direction"
        },
        "opcode_str": {
          "description": "This optional field is just for if you don't care about json file size and you want more human-readable JSON output.",
          "type": "string",
          "const": "LL_CONNECTION_PARAM_RSP"
        },
        "opcode": {
          "description": "This should always be 16. This is required to differentiate from other data types in an array.",
          "const": 16
        },
        "interval_min": {
          "description": "The minimum connection interval. (Multiplied by 1.25ms). This should technically be only between 7.5ms to 4.0s (6-3200) according to the spec, but put in whatever was actually used.",
          "type": "integer",
          "minimum": 0,
          "maximum": 65535
        },
        "interval_max": {
          "description": "The maximum connection interval. (Multiplied by 1.25ms). This should technically be only between 7.5ms to 4.0s (6-3200) according to the spec, but put in whatever was actually used.",
          "type": "integer",
          "minimum": 0,
          "maximum": 65535
        },
        "latency": {
          "description": "The Peripheral latency (how many connection events the Peripheral can skip replying to.). \"The value of connSubrateFactor shall be in the range 1 to 500 and shall be set to 1 for a new connection\" to be valid according to the spec, but put whatever value was actually found in the packet.",
          "type": "integer",
          "minimum": 0,
          "maximum": 65535
        },
        "timeout": {
          "description": "The connection timeout. (Multiplied by 10ms). \"The connSupervisionTimeout shall be a multiple of 10 ms in the range 100 ms to 32.0s and it shall be larger than (1 + connPeripheralLatency) × connSubrateFactor × connInterval × 2.\" (so 1-3200)according to the spec, but put in whatever was actually used.",
          "type": "integer",
          "minimum": 0,
          "maximum": 65535
        },
        "preferred_periodicity": {
          "description": "Multiplied by 1.25ms. 'The PreferredPeriodicity field shall be set to indicate a value the connInterval is preferred to be a multiple of.'",
          "type": "integer",
          "minimum": 0,
          "maximum": 255
        },
        "reference_conneventcount": {
          "description": "'The ReferenceConnEventCount field shall be set to indicate the value of the connEventCounter relative to which all the valid Offset0 to Offset5 fields have been calculated.'",
          "type": "integer",
          "minimum": 0,
          "maximum": 65535
        },
        "offset0": {
          "description": "'The Offset0, Offset1, Offset2, Offset3, Offset4, and Offset5 fields shall be set to indicate the possible values of the position of the anchor points of the LE connection with the updated connection parameters relative to the ReferenceConnEventCount.' + 'A value of 0xFFFF means not valid.'",
          "type": "integer",
          "minimum": 0,
          "maximum": 65535
        },
        "offset1": {
          "description": "'The Offset0, Offset1, Offset2, Offset3, Offset4, and Offset5 fields shall be set to indicate the possible values of the position of the anchor points of the LE connection with the updated connection parameters relative to the ReferenceConnEventCount.' + 'A value of 0xFFFF means not valid.'",
          "type": "integer",
          "minimum": 0,
          "maximum": 65535
        },
        "offset2": {
          "description": "'The Offset0, Offset1, Offset2, Offset3, Offset4, and Offset5 fields shall be set to indicate the possible values of the position of the anchor points of the LE connection with the updated connection parameters relative to the ReferenceConnEventCount.' + 'A value of 0xFFFF means not valid.'",
          "type": "integer",
          "minimum": 0,
          "maximum": 65535
        },
        "offset3": {
          "description": "'The Offset0, Offset1, Offset2, Offset3, Offset4, and Offset5 fields shall be set to indicate the possible values of the position of the anchor points of the LE connection with the updated connection parameters relative to the ReferenceConnEventCount.' + 'A value of 0xFFFF means not valid.'",
          "type": "integer",
          "minimum": 0,
          "maximum": 65535
        },
        "offset4": {
          "description": "'The Offset0, Offset1, Offset2, Offset3, Offset4, and Offset5 fields shall be set to indicate the possible values of the position of the anchor points of the LE connection with the updated connection parameters relative to the ReferenceConnEventCount.' + 'A value of 0xFFFF means not valid.'",
          "type": "integer",
          "minimum": 0,
          "maximum": 65535
        },
        "offset5": {
          "description": "'The Offset0, Offset1, Offset2, Offset3, Offset4, and Offset5 fields shall be set to indicate the possible values of the position of the anchor points of the LE connection with the updated connection parameters relative to the ReferenceConnEventCount.' + 'A value of 0xFFFF means not valid.'",
          "type": "integer",
          "minimum": 0,
          "maximum": 65535
        }
      }
    },
    "LL_CONNECTION_PARAM_RSP2": {
      "type": "object",
      "description": "Structure for LL\\_CONNECTION\\_PARAM\\_RSP packet.",
      "required": [
        "direction",
        "opcode",
        "full_pkt_hex_str"
      ],
      "properties": {
        "std_optional_fields": {
          "$ref": "BTIDES_base.json#/definitions/std_optional_fields"
        },
        "direction": {
          "$ref": "BTIDES_base.json#/definitions/direction"
        },
        "opcode_str": {
          "description": "This optional field is just for if you don't care about json file size and you want more human-readable JSON output.",
          "type": "string",
          "const": "LL_PERIPHERAL_FEATURE_RSP"
        },
        "opcode": {
          "description": "This should always be 16. This is required to differentiate from other data types in an array.",
          "const": 16
        },
        "full_pkt_hex_str": {
          "$ref": "BTIDES_base.json#/definitions/full_pkt_hex_str"
        }
      }
    },
    "LL_PING_REQ": {
      "type": "object",
      "description": "Structure for LL\\_PING\\_REQ packet.",
      "required": [
        "direction",
        "opcode"
      ],
      "properties": {
        "std_optional_fields": {
          "$ref": "BTIDES_base.json#/definitions/std_optional_fields"
        },
        "direction": {
          "$ref": "BTIDES_base.json#/definitions/direction"
        },
        "opcode_str": {
          "description": "This optional field is just for if you don't care about json file size and you want more human-readable JSON output.",
          "type": "string",
          "const": "LL_PING_REQ"
        },
        "opcode": {
          "description": "This should always be 18. This is required to differentiate from other data types in an array.",
          "const": 18
        }
      }
    },
    "LL_PING_RSP": {
      "type": "object",
      "description": "Structure for LL\\_PING\\_RSP packet.",
      "required": [
        "direction",
        "opcode"
      ],
      "properties": {
        "std_optional_fields": {
          "$ref": "BTIDES_base.json#/definitions/std_optional_fields"
        },
        "direction": {
          "$ref": "BTIDES_base.json#/definitions/direction"
        },
        "opcode_str": {
          "description": "This optional field is just for if you don't care about json file size and you want more human-readable JSON output.",
          "type": "string",
          "const": "LL_PING_RSP"
        },
        "opcode": {
          "description": "This should always be 19. This is required to differentiate from other data types in an array.",
          "const": 19
        }
      }
    },
    "LL_LENGTH_REQ": {
      "type": "object",
      "description": "Structure for LL\\_LENGTH\\_REQ packet.",
      "required": [
        "direction",
        "opcode",
        "max_rx_octets",
        "max_rx_time",
        "max_tx_octets",
        "max_tx_time"
      ],
      "properties": {
        "std_optional_fields": {
          "$ref": "BTIDES_base.json#/definitions/std_optional_fields"
        },
        "direction": {
          "$ref": "BTIDES_base.json#/definitions/direction"
        },
        "opcode_str": {
          "description": "This optional field is just for if you don't care about json file size and you want more human-readable JSON output.",
          "type": "string",
          "const": "LL_LENGTH_REQ"
        },
        "opcode": {
          "description": "This should always be 20. This is required to differentiate from other data types in an array.",
          "const": 20
        },
        "max_rx_octets": {
          "description": "2-byte MaxRxOctets from BT Core Spec.",
          "type": "integer",
          "minimum": 0,
          "maximum": 65535
        },
        "max_rx_time": {
          "description": "2-byte MaxRxTime from BT Core Spec.",
          "type": "integer",
          "minimum": 0,
          "maximum": 65535
        },
        "max_tx_octets": {
          "description": "2-byte MaxTxOctets from BT Core Spec.",
          "type": "integer",
          "minimum": 0,
          "maximum": 65535
        },
        "max_tx_time": {
          "description": "2-byte MaxTxTime from BT Core Spec.",
          "type": "integer",
          "minimum": 0,
          "maximum": 65535
        }
      }
    },
    "LL_LENGTH_REQ2": {
      "type": "object",
      "description": "Structure for LL\\_LENGTH\\_REQ packet, as single raw hex string.",
      "required": [
        "direction",
        "opcode",
        "full_pkt_hex_str"
      ],
      "properties": {
        "std_optional_fields": {
          "$ref": "BTIDES_base.json#/definitions/std_optional_fields"
        },
        "direction": {
          "$ref": "BTIDES_base.json#/definitions/direction"
        },
        "opcode_str": {
          "description": "This optional field is just for if you don't care about json file size and you want more human-readable JSON output.",
          "type": "string",
          "const": "LL_LENGTH_REQ"
        },
        "opcode": {
          "description": "This should always be 20. This is required to differentiate from other data types in an array.",
          "const": 20
        },
        "full_pkt_hex_str": {
          "$ref": "BTIDES_base.json#/definitions/full_pkt_hex_str"
        }
      }
    },
    "LL_LENGTH_RSP": {
      "type": "object",
      "description": "Structure for LL\\_LENGTH\\_RSP packet.",
      "required": [
        "direction",
        "opcode",
        "max_rx_octets",
        "max_rx_time",
        "max_tx_octets",
        "max_tx_time"
      ],
      "properties": {
        "std_optional_fields": {
          "$ref": "BTIDES_base.json#/definitions/std_optional_fields"
        },
        "direction": {
          "$ref": "BTIDES_base.json#/definitions/direction"
        },
        "opcode_str": {
          "description": "This optional field is just for if you don't care about json file size and you want more human-readable JSON output.",
          "type": "string",
          "const": "LL_LENGTH_RSP"
        },
        "opcode": {
          "description": "This should always be 21. This is required to differentiate from other data types in an array.",
          "const": 21
        },
        "max_rx_octets": {
          "description": "2-byte MaxRxOctets from BT Core Spec.",
          "type": "integer",
          "minimum": 0,
          "maximum": 65535
        },
        "max_rx_time": {
          "description": "2-byte MaxRxTime from BT Core Spec.",
          "type": "integer",
          "minimum": 0,
          "maximum": 65535
        },
        "max_tx_octets": {
          "description": "2-byte MaxTxOctets from BT Core Spec.",
          "type": "integer",
          "minimum": 0,
          "maximum": 65535
        },
        "max_tx_time": {
          "description": "2-byte MaxTxTime from BT Core Spec.",
          "type": "integer",
          "minimum": 0,
          "maximum": 65535
        }
      }
    },
    "LL_LENGTH_RSP2": {
      "type": "object",
      "description": "Structure for LL\\_LENGTH\\_RSP packet, as single raw hex string.",
      "required": [
        "direction",
        "opcode",
        "full_pkt_hex_str"
      ],
      "properties": {
        "std_optional_fields": {
          "$ref": "BTIDES_base.json#/definitions/std_optional_fields"
        },
        "direction": {
          "$ref": "BTIDES_base.json#/definitions/direction"
        },
        "opcode_str": {
          "description": "This optional field is just for if you don't care about json file size and you want more human-readable JSON output.",
          "type": "string",
          "const": "LL_LENGTH_RSP"
        },
        "opcode": {
          "description": "This should always be 21. This is required to differentiate from other data types in an array.",
          "const": 21
        },
        "full_pkt_hex_str": {
          "$ref": "BTIDES_base.json#/definitions/full_pkt_hex_str"
        }
      }
    },
    "LL_PHY_REQ": {
      "type": "object",
      "description": "Structure for LL\\_PHY\\_REQ packet.",
      "required": [
        "direction",
        "opcode",
        "TX_PHYS",
        "RX_PHYS"
      ],
      "properties": {
        "std_optional_fields": {
          "$ref": "BTIDES_base.json#/definitions/std_optional_fields"
        },
        "direction": {
          "$ref": "BTIDES_base.json#/definitions/direction"
        },
        "opcode_str": {
          "description": "This optional field is just for if you don't care about json file size and you want more human-readable JSON output.",
          "type": "string",
          "const": "LL_PHY_REQ"
        },
        "opcode": {
          "description": "This should always be 22. This is required to differentiate from other data types in an array.",
          "const": 22
        },
        "TX_PHYS": {
          "description": "1-byte TX_PHYS from BT Core Spec.",
          "type": "integer",
          "minimum": 0,
          "maximum": 255
        },
        "RX_PHYS": {
          "description": "1-byte RX_PHYS from BT Core Spec.",
          "type": "integer",
          "minimum": 0,
          "maximum": 255
        }
      }
    },
    "LL_PHY_REQ2": {
      "type": "object",
      "description": "Structure for LL\\_PHY\\_REQ packet, as single raw hex string.",
      "required": [
        "direction",
        "opcode",
        "full_pkt_hex_str"
      ],
      "properties": {
        "std_optional_fields": {
          "$ref": "BTIDES_base.json#/definitions/std_optional_fields"
        },
        "direction": {
          "$ref": "BTIDES_base.json#/definitions/direction"
        },
        "opcode_str": {
          "description": "This optional field is just for if you don't care about json file size and you want more human-readable JSON output.",
          "type": "string",
          "const": "LL_PHY_REQ"
        },
        "opcode": {
          "description": "This should always be 22. This is required to differentiate from other data types in an array.",
          "const": 22
        },
        "full_pkt_hex_str": {
          "$ref": "BTIDES_base.json#/definitions/full_pkt_hex_str"
        }
      }
    },
    "LL_PHY_RSP": {
      "type": "object",
      "description": "Structure for LL\\_PHY\\_RSP packet.",
      "required": [
        "direction",
        "opcode",
        "TX_PHYS",
        "RX_PHYS"
      ],
      "properties": {
        "std_optional_fields": {
          "$ref": "BTIDES_base.json#/definitions/std_optional_fields"
        },
        "direction": {
          "$ref": "BTIDES_base.json#/definitions/direction"
        },
        "opcode_str": {
          "description": "This optional field is just for if you don't care about json file size and you want more human-readable JSON output.",
          "type": "string",
          "const": "LL_PHY_RSP"
        },
        "opcode": {
          "description": "This should always be 23. This is required to differentiate from other data types in an array.",
          "const": 23
        },
        "TX_PHYS": {
          "description": "1-byte TX_PHYS from BT Core Spec.",
          "type": "integer",
          "minimum": 0,
          "maximum": 255
        },
        "RX_PHYS": {
          "description": "1-byte RX_PHYS from BT Core Spec.",
          "type": "integer",
          "minimum": 0,
          "maximum": 255
        }
      }
    },
    "LL_PHY_RSP2": {
      "type": "object",
      "description": "Structure for LL\\_PHY\\_RSP packet, as single raw hex string.",
      "required": [
        "direction",
        "opcode",
        "full_pkt_hex_str"
      ],
      "properties": {
        "std_optional_fields": {
          "$ref": "BTIDES_base.json#/definitions/std_optional_fields"
        },
        "direction": {
          "$ref": "BTIDES_base.json#/definitions/direction"
        },
        "opcode_str": {
          "description": "This optional field is just for if you don't care about json file size and you want more human-readable JSON output.",
          "type": "string",
          "const": "LL_PHY_RSP"
        },
        "opcode": {
          "description": "This should always be 23. This is required to differentiate from other data types in an array.",
          "const": 23
        },
        "full_pkt_hex_str": {
          "$ref": "BTIDES_base.json#/definitions/full_pkt_hex_str"
        }
      }
    }
  }
}