{
  "$id": "https://darkmentor.com/BTIDES_Schema/BTIDES_LMP.json",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "description": "BTIDES LMP packet information data types",
  "type": "object",
  "properties": {
    "LMPArray": {
      "type": "array",
      "items": {
        "anyOf": [
          {
            "$ref": "#/definitions/LMP_NAME_REQ"
          },
          {
            "$ref": "#/definitions/LMP_NAME_REQ2"
          },
          {
            "$ref": "#/definitions/LMP_NAME_RES"
          },
          {
            "$ref": "#/definitions/LMP_NAME_RES2"
          },
          {
            "$ref": "#/definitions/LMP_ACCEPTED"
          },
          {
            "$ref": "#/definitions/LMP_ACCEPTED2"
          },
          {
            "$ref": "#/definitions/LMP_NOT_ACCEPTED"
          },
          {
            "$ref": "#/definitions/LMP_NOT_ACCEPTED2"
          },
          {
            "$ref": "#/definitions/LMP_DETACH"
          },
          {
            "$ref": "#/definitions/LMP_DETACH2"
          },
          {
            "$ref": "#/definitions/LMP_AUTO_RATE"
          },
          {
            "$ref": "#/definitions/LMP_PREFERRED_RATE"
          },
          {
            "$ref": "#/definitions/LMP_PREFERRED_RATE2"
          },
          {
            "$ref": "#/definitions/LMP_VERSION_REQ"
          },
          {
            "$ref": "#/definitions/LMP_VERSION_REQ2"
          },
          {
            "$ref": "#/definitions/LMP_VERSION_RES"
          },
          {
            "$ref": "#/definitions/LMP_VERSION_RES2"
          },
          {
            "$ref": "#/definitions/LMP_FEATURES_REQ"
          },
          {
            "$ref": "#/definitions/LMP_FEATURES_REQ2"
          },
          {
            "$ref": "#/definitions/LMP_FEATURES_RES"
          },
          {
            "$ref": "#/definitions/LMP_FEATURES_RES2"
          },
          {
            "$ref": "#/definitions/LMP_MAX_SLOT"
          },
          {
            "$ref": "#/definitions/LMP_MAX_SLOT2"
          },
          {
            "$ref": "#/definitions/LMP_MAX_SLOT_REQ"
          },
          {
            "$ref": "#/definitions/LMP_MAX_SLOT_REQ2"
          },
          {
            "$ref": "#/definitions/LMP_TIMING_ACCURACY_REQ"
          },
          {
            "$ref": "#/definitions/LMP_TIMING_ACCURACY_RES"
          },
          {
            "$ref": "#/definitions/LMP_TIMING_ACCURACY_RES2"
          },
          {
            "$ref": "#/definitions/LMP_ENCRYPTION_KEY_SIZE_MASK_REQ"
          },
          {
            "$ref": "#/definitions/LMP_ENCRYPTION_KEY_SIZE_MASK_RES"
          },
          {
            "$ref": "#/definitions/LMP_ENCRYPTION_KEY_SIZE_MASK_RES2"
          },
          {
            "$ref": "#/definitions/LMP_SETUP_COMPLETE"
          },
          {
            "$ref": "#/definitions/LMP_ACCEPTED_EXT"
          },
          {
            "$ref": "#/definitions/LMP_ACCEPTED_EXT2"
          },
          {
            "$ref": "#/definitions/LMP_NOT_ACCEPTED_EXT"
          },
          {
            "$ref": "#/definitions/LMP_NOT_ACCEPTED_EXT2"
          },
          {
            "$ref": "#/definitions/LMP_FEATURES_REQ_EXT"
          },
          {
            "$ref": "#/definitions/LMP_FEATURES_REQ_EXT2"
          },
          {
            "$ref": "#/definitions/LMP_FEATURES_RES_EXT"
          },
          {
            "$ref": "#/definitions/LMP_FEATURES_RES_EXT2"
          },
          {
            "$ref": "#/definitions/LMP_CHANNEL_CLASSIFICATION"
          },
          {
            "$ref": "#/definitions/LMP_CHANNEL_CLASSIFICATION2"
          },
          {
            "$ref": "#/definitions/LMP_POWER_CONTROL_REQ"
          },
          {
            "$ref": "#/definitions/LMP_POWER_CONTROL_REQ2"
          },
          {
            "$ref": "#/definitions/LMP_POWER_CONTROL_RES"
          },
          {
            "$ref": "#/definitions/LMP_POWER_CONTROL_RES2"
          }
        ]
      }
    }
  },
  "definitions": {
    "LMP_NAME_REQ": {
      "type": "object",
      "description": "Structure for LMP\\_NAME\\_REQ packet.",
      "required": [
        "opcode",
        "name_offset"
      ],
      "properties": {
        "std_optional_fields": {
          "$ref": "BTIDES_base.json#/definitions/std_optional_fields"
        },
        "opcode_str": {
          "description": "This optional field is just for if you don't care about json file size and you want more human-readable JSON output.",
          "type": "string",
          "const": "LMP_NAME_REQ"
        },
        "opcode": {
          "description": "This should always be 1. This is required to differentiate from other data types in an array.",
          "const": 1
        },
        "name_offset": {
          "description": "1-byte value signifying the offset within the name to retrieve from.",
          "type": "integer",
          "minimum": 0,
          "maximum": 255
        }
      }
    },
    "LMP_NAME_REQ2": {
      "type": "object",
      "description": "Structure for LMP\\_NAME\\_REQ packet, as single raw hex string.",
      "required": [
        "opcode",
        "full_pkt_hex_str"
      ],
      "properties": {
        "std_optional_fields": {
          "$ref": "BTIDES_base.json#/definitions/std_optional_fields"
        },
        "opcode_str": {
          "description": "This optional field is just for if you don't care about json file size and you want more human-readable JSON output.",
          "type": "string",
          "const": "LMP_NAME_REQ"
        },
        "opcode": {
          "description": "This should always be 1. This is required to differentiate from other data types in an array.",
          "const": 1
        },
        "full_pkt_hex_str": {
          "$ref": "BTIDES_base.json#/definitions/full_pkt_hex_str"
        }
      }
    },
    "LMP_NAME_RES": {
      "type": "object",
      "description": "Structure for LMP\\_NAME\\_RES packet.",
      "required": [
        "opcode",
        "name_offset",
        "name_length",
        "name_fragment_hex_str"
      ],
      "properties": {
        "std_optional_fields": {
          "$ref": "BTIDES_base.json#/definitions/std_optional_fields"
        },
        "opcode_str": {
          "description": "This optional field is just for if you don't care about json file size and you want more human-readable JSON output.",
          "type": "string",
          "const": "LMP_NAME_RES"
        },
        "opcode": {
          "description": "This should always be 2. This is required to differentiate from other data types in an array.",
          "const": 2
        },
        "name_offset": {
          "description": "1-byte value signifying the offset within the name to retrieve from.",
          "type": "integer",
          "minimum": 0,
          "maximum": 255
        },
        "name_length": {
          "description": "1-byte value signifying the total length of the device name. (Used to determine if the name_fragment is the full name or there's more to retrieve.)",
          "type": "integer",
          "minimum": 0,
          "maximum": 255
        },
        "name_fragment_hex_str": {
          "description": "A portion of the device name, as single raw hex string..",
          "type": "string"
        }
      }
    },
    "LMP_NAME_RES2": {
      "type": "object",
      "description": "Structure for LMP\\_NAME\\_RES packet, as single raw hex string.",
      "required": [
        "opcode",
        "full_pkt_hex_str"
      ],
      "properties": {
        "std_optional_fields": {
          "$ref": "BTIDES_base.json#/definitions/std_optional_fields"
        },
        "opcode_str": {
          "description": "This optional field is just for if you don't care about json file size and you want more human-readable JSON output.",
          "type": "string",
          "const": "LMP_NAME_RES"
        },
        "opcode": {
          "description": "This should always be 2. This is required to differentiate from other data types in an array.",
          "const": 2
        },
        "full_pkt_hex_str": {
          "$ref": "BTIDES_base.json#/definitions/full_pkt_hex_str"
        }
      }
    },
    "rcvd_opcode": {
      "description": "One byte value indicating the opcode of the LMP command being accepted or not accepted.",
      "type": "integer",
      "minimum": 0,
      "maximum": 255
    },
    "rcvd_opcode_str": {
      "description": "Optional string version of the rcvd_opcode (e.g. like 'LMP\\_ACCEPTED').",
      "type": "string",
      "maximum": 33
    },
    "LMP_ACCEPTED": {
      "type": "object",
      "description": "Structure for LMP\\_ACCEPTED packet.",
      "required": [
        "opcode",
        "rcvd_opcode"
      ],
      "properties": {
        "std_optional_fields": {
          "$ref": "BTIDES_base.json#/definitions/std_optional_fields"
        },
        "opcode_str": {
          "description": "This optional field is just for if you don't care about json file size and you want more human-readable JSON output.",
          "type": "string",
          "const": "LMP_ACCEPTED"
        },
        "opcode": {
          "description": "This should always be 3. This is required to differentiate from other data types in an array.",
          "const": 3
        },
        "rcvd_opcode": {
          "$ref": "#/definitions/rcvd_opcode"
        },
        "rcvd_opcode_str": {
          "$ref": "#/definitions/rcvd_opcode_str"
        }
      }
    },
    "LMP_ACCEPTED2": {
      "type": "object",
      "description": "Structure for LMP\\_ACCEPTED packet, as single raw hex string.",
      "required": [
        "opcode",
        "full_pkt_hex_str"
      ],
      "properties": {
        "std_optional_fields": {
          "$ref": "BTIDES_base.json#/definitions/std_optional_fields"
        },
        "opcode_str": {
          "description": "This optional field is just for if you don't care about json file size and you want more human-readable JSON output.",
          "type": "string",
          "const": "LMP_ACCEPTED"
        },
        "opcode": {
          "description": "This should always be 3. This is required to differentiate from other data types in an array.",
          "const": 3
        },
        "full_pkt_hex_str": {
          "description": "This should *exclude* the opcode byte. Therefore it will always be exactly 1 byte / 2 hex characters.",
          "$ref": "BTIDES_base.json#/definitions/full_pkt_hex_str",
          "minLength": 2,
          "maxLength": 2
        }
      }
    },
    "error_code": {
      "description": "One byte value indicating the reason for rejection.",
      "type": "integer",
      "minimum": 0,
      "maximum": 255
    },
    "error_code_str": {
      "description": "Optional string version of the error_code (e.g. like 'Synchronous Connection Limit To A Device Exceeded').",
      "type": "string"
    },
    "LMP_NOT_ACCEPTED": {
      "type": "object",
      "description": "Structure for LMP\\_NOT\\_ACCEPTED packet.",
      "required": [
        "opcode",
        "rcvd_opcode",
        "error_code"
      ],
      "properties": {
        "std_optional_fields": {
          "$ref": "BTIDES_base.json#/definitions/std_optional_fields"
        },
        "opcode_str": {
          "description": "This optional field is just for if you don't care about json file size and you want more human-readable JSON output.",
          "type": "string",
          "const": "LMP_NOT_ACCEPTED"
        },
        "opcode": {
          "description": "This should always be 4. This is required to differentiate from other data types in an array.",
          "const": 4
        },
        "rcvd_opcode": {
          "$ref": "#/definitions/rcvd_opcode"
        },
        "rcvd_opcode_str": {
          "$ref": "#/definitions/rcvd_opcode_str"
        },
        "error_code": {
          "$ref": "#/definitions/error_code"
        },
        "error_code_str": {
          "$ref": "#/definitions/error_code_str"
        }
      }
    },
    "LMP_NOT_ACCEPTED2": {
      "type": "object",
      "description": "Structure for LMP\\_NOT\\_ACCEPTED packet, as single raw hex string.",
      "required": [
        "opcode",
        "full_pkt_hex_str"
      ],
      "properties": {
        "std_optional_fields": {
          "$ref": "BTIDES_base.json#/definitions/std_optional_fields"
        },
        "opcode_str": {
          "description": "This optional field is just for if you don't care about json file size and you want more human-readable JSON output.",
          "type": "string",
          "const": "LMP_NOT_ACCEPTED"
        },
        "opcode": {
          "description": "This should always be 4. This is required to differentiate from other data types in an array.",
          "const": 4
        },
        "full_pkt_hex_str": {
          "description": "This should *exclude* the opcode byte. Therefore it will always be exactly 2 bytes / 4 hex characters.",
          "$ref": "BTIDES_base.json#/definitions/full_pkt_hex_str",
          "minLength": 4,
          "maxLength": 4
        }
      }
    },
    "LMP_DETACH": {
      "type": "object",
      "description": "Structure for LMP\\_DETACH packet.",
      "required": [
        "opcode",
        "error_code"
      ],
      "properties": {
        "std_optional_fields": {
          "$ref": "BTIDES_base.json#/definitions/std_optional_fields"
        },
        "opcode_str": {
          "description": "This optional field is just for if you don't care about json file size and you want more human-readable JSON output.",
          "type": "string",
          "const": "LMP_DETACH"
        },
        "opcode": {
          "description": "This should always be 7. This is required to differentiate from other data types in an array.",
          "const": 7
        },
        "error_code": {
          "$ref": "#/definitions/error_code"
        },
        "error_code_str": {
          "$ref": "#/definitions/error_code_str"
        }
      }
    },
    "LMP_DETACH2": {
      "type": "object",
      "description": "Structure for LMP\\_DETACH packet, as single raw hex string.",
      "required": [
        "opcode",
        "full_pkt_hex_str"
      ],
      "properties": {
        "std_optional_fields": {
          "$ref": "BTIDES_base.json#/definitions/std_optional_fields"
        },
        "opcode_str": {
          "description": "This optional field is just for if you don't care about json file size and you want more human-readable JSON output.",
          "type": "string",
          "const": "LMP_DETACH"
        },
        "opcode": {
          "description": "This should always be 7. This is required to differentiate from other data types in an array.",
          "const": 7
        },
        "full_pkt_hex_str": {
          "description": "This should *exclude* the opcode byte. Therefore it will always be exactly 1 bytes / 2 hex characters.",
          "$ref": "BTIDES_base.json#/definitions/full_pkt_hex_str",
          "minLength": 2,
          "maxLength": 2
        }
      }
    },
    "LMP_AUTO_RATE": {
      "type": "object",
      "description": "Structure for LMP\\_AUTO\\_RATEpacket (which is defined as only an opcode, no payload).",
      "required": [
        "opcode"
      ],
      "properties": {
        "std_optional_fields": {
          "$ref": "BTIDES_base.json#/definitions/std_optional_fields"
        },
        "opcode_str": {
          "description": "This optional field is just for if you don't care about json file size and you want more human-readable JSON output.",
          "type": "string",
          "const": "LMP_AUTO_RATE"
        },
        "opcode": {
          "description": "This should always be 35. This is required to differentiate from other data types in an array.",
          "const": 35
        }
      }
    },
    "LMP_PREFERRED_RATE": {
      "type": "object",
      "description": "Structure for LMP\\_PREFERRED\\_RATE packet.",
      "required": [
        "opcode",
        "data_rate"
      ],
      "properties": {
        "std_optional_fields": {
          "$ref": "BTIDES_base.json#/definitions/std_optional_fields"
        },
        "opcode_str": {
          "description": "This optional field is just for if you don't care about json file size and you want more human-readable JSON output.",
          "type": "string",
          "const": "LMP_PREFERRED_RATE"
        },
        "opcode": {
          "description": "This should always be 36. This is required to differentiate from other data types in an array.",
          "const": 36
        },
        "data_rate": {
          "description": "1-byte value indicating the preferred data rate. Different interpretations when using BR vs. EDR. (See spec.)",
          "type": "integer"
        }
      }
    },
    "LMP_PREFERRED_RATE2": {
      "type": "object",
      "description": "Structure for LMP\\_PREFERRED\\_RATE packet, as single raw hex string.",
      "required": [
        "opcode",
        "full_pkt_hex_str"
      ],
      "properties": {
        "std_optional_fields": {
          "$ref": "BTIDES_base.json#/definitions/std_optional_fields"
        },
        "opcode_str": {
          "description": "This optional field is just for if you don't care about json file size and you want more human-readable JSON output.",
          "type": "string",
          "const": "LMP_PREFERRED_RATE"
        },
        "opcode": {
          "description": "This should always be 36. This is required to differentiate from other data types in an array.",
          "const": 36
        },
        "full_pkt_hex_str": {
          "description": "This should *exclude* the opcode byte. Therefore it will always be exactly 1 byte / 2 hex characters.",
          "$ref": "BTIDES_base.json#/definitions/full_pkt_hex_str",
          "minLength": 2,
          "maxLength": 2
        }
      }
    },
    "LMP_VERSION_REQ": {
      "type": "object",
      "description": "Structure for LMP\\_VERSION\\_REQ packet.",
      "required": [
        "opcode",
        "version",
        "company_id",
        "subversion"
      ],
      "properties": {
        "std_optional_fields": {
          "$ref": "BTIDES_base.json#/definitions/std_optional_fields"
        },
        "opcode_str": {
          "description": "This optional field is just for if you don't care about json file size and you want more human-readable JSON output.",
          "type": "string",
          "const": "LMP_VERSION_REQ"
        },
        "opcode": {
          "description": "This should always be 37. This is required to differentiate from other data types in an array.",
          "const": 37
        },
        "version": {
          "$ref": "BTIDES_LLCP.json#/definitions/version"
        },
        "company_id": {
          "$ref": "BTIDES_LLCP.json#/definitions/company_id"
        },
        "subversion": {
          "$ref": "BTIDES_LLCP.json#/definitions/subversion"
        }
      }
    },
    "LMP_VERSION_REQ2": {
      "type": "object",
      "description": "Structure for LMP\\_VERSION\\_REQ packet, as single raw hex string.",
      "required": [
        "opcode",
        "full_pkt_hex_str"
      ],
      "properties": {
        "std_optional_fields": {
          "$ref": "BTIDES_base.json#/definitions/std_optional_fields"
        },
        "opcode_str": {
          "description": "This optional field is just for if you don't care about json file size and you want more human-readable JSON output.",
          "type": "string",
          "const": "LMP_VERSION_REQ"
        },
        "opcode": {
          "description": "This should always be 37. This is required to differentiate from other data types in an array.",
          "const": 37
        },
        "full_pkt_hex_str": {
          "description": "This should *exclude* the opcode byte. Therefore it will always be exactly 5 bytes / 10 hex characters.",
          "$ref": "BTIDES_base.json#/definitions/full_pkt_hex_str",
          "minLength": 10,
          "maxLength": 10
        }
      }
    },
    "LMP_VERSION_RES": {
      "type": "object",
      "description": "Structure for LMP\\_VERSION\\_RES packet.",
      "required": [
        "opcode",
        "version",
        "company_id",
        "subversion"
      ],
      "properties": {
        "std_optional_fields": {
          "$ref": "BTIDES_base.json#/definitions/std_optional_fields"
        },
        "opcode_str": {
          "description": "This optional field is just for if you don't care about json file size and you want more human-readable JSON output.",
          "type": "string",
          "const": "LMP_VERSION_RES"
        },
        "opcode": {
          "description": "This should always be 38. This is required to differentiate from other data types in an array.",
          "const": 38
        },
        "version": {
          "$ref": "BTIDES_LLCP.json#/definitions/version"
        },
        "company_id": {
          "$ref": "BTIDES_LLCP.json#/definitions/company_id"
        },
        "subversion": {
          "$ref": "BTIDES_LLCP.json#/definitions/subversion"
        }
      }
    },
    "LMP_VERSION_RES2": {
      "type": "object",
      "description": "Structure for LMP\\_VERSION\\_RES packet, as single raw hex string.",
      "required": [
        "opcode",
        "full_pkt_hex_str"
      ],
      "properties": {
        "std_optional_fields": {
          "$ref": "BTIDES_base.json#/definitions/std_optional_fields"
        },
        "opcode_str": {
          "description": "This optional field is just for if you don't care about json file size and you want more human-readable JSON output.",
          "type": "string",
          "const": "LMP_VERSION_RES"
        },
        "opcode": {
          "description": "This should always be 38. This is required to differentiate from other data types in an array.",
          "const": 38
        },
        "full_pkt_hex_str": {
          "description": "This should *exclude* the opcode byte. Therefore it will always be exactly 5 bytes / 10 hex characters.",
          "$ref": "BTIDES_base.json#/definitions/full_pkt_hex_str",
          "minLength": 10,
          "maxLength": 10
        }
      }
    },
    "lmp_features_hex_str": {
      "description": "8-byte value as hex string.",
      "type": "string",
      "minLength": 16,
      "maxLength": 16
    },
    "LMP_FEATURES_REQ": {
      "type": "object",
      "description": "Structure for LMP\\_FEATURES\\_REQ packet.",
      "required": [
        "opcode",
        "lmp_features_hex_str"
      ],
      "properties": {
        "std_optional_fields": {
          "$ref": "BTIDES_base.json#/definitions/std_optional_fields"
        },
        "opcode_str": {
          "description": "This optional field is just for if you don't care about json file size and you want more human-readable JSON output.",
          "type": "string",
          "const": "LMP_FEATURES_REQ"
        },
        "opcode": {
          "description": "Optional field just if you don't want to look up the opcode for this packet type.",
          "const": 39
        },
        "lmp_features_hex_str": {
          "$ref": "#/definitions/lmp_features_hex_str"
        }
      }
    },
    "LMP_FEATURES_REQ2": {
      "type": "object",
      "description": "Structure for LMP\\_FEATURES\\_REQ packet, as single raw hex string.",
      "required": [
        "opcode",
        "full_pkt_hex_str"
      ],
      "properties": {
        "std_optional_fields": {
          "$ref": "BTIDES_base.json#/definitions/std_optional_fields"
        },
        "opcode_str": {
          "description": "This optional field is just for if you don't care about json file size and you want more human-readable JSON output.",
          "type": "string",
          "const": "LMP_FEATURES_REQ"
        },
        "opcode": {
          "description": "This should always be 39. This is required to differentiate from other data types in an array.",
          "const": 39
        },
        "full_pkt_hex_str": {
          "description": "This should *exclude* the opcode byte. Therefore it will always be exactly 8 bytes / 16 hex characters.",
          "$ref": "BTIDES_base.json#/definitions/full_pkt_hex_str",
          "minLength": 16,
          "maxLength": 16
        }
      }
    },
    "LMP_FEATURES_RES": {
      "type": "object",
      "description": "Structure for LMP\\_FEATURES\\_RES packet.",
      "required": [
        "opcode",
        "lmp_features_hex_str"
      ],
      "properties": {
        "std_optional_fields": {
          "$ref": "BTIDES_base.json#/definitions/std_optional_fields"
        },
        "opcode_str": {
          "description": "This optional field is just for if you don't care about json file size and you want more human-readable JSON output.",
          "type": "string",
          "const": "LMP_FEATURES_RES"
        },
        "opcode": {
          "description": "This should always be 40. This is required to differentiate from other data types in an array.",
          "const": 40
        },
        "lmp_features_hex_str": {
          "$ref": "#/definitions/lmp_features_hex_str"
        }
      }
    },
    "LMP_FEATURES_RES2": {
      "type": "object",
      "description": "Structure for LMP\\_FEATURES\\_RES packet, as single raw hex string.",
      "required": [
        "opcode",
        "full_pkt_hex_str"
      ],
      "properties": {
        "std_optional_fields": {
          "$ref": "BTIDES_base.json#/definitions/std_optional_fields"
        },
        "opcode_str": {
          "description": "This optional field is just for if you don't care about json file size and you want more human-readable JSON output.",
          "type": "string",
          "const": "LMP_FEATURES_RES"
        },
        "opcode": {
          "description": "This should always be 40. This is required to differentiate from other data types in an array.",
          "const": 40
        },
        "full_pkt_hex_str": {
          "description": "This should *exclude* the opcode byte. Therefore it will always be exactly 8 bytes / 16 hex characters.",
          "$ref": "BTIDES_base.json#/definitions/full_pkt_hex_str",
          "minLength": 16,
          "maxLength": 16
        }
      }
    },
    "LMP_MAX_SLOT": {
      "type": "object",
      "description": "Structure for LMP\\_MAX\\_SLOT packet.",
      "required": [
        "opcode",
        "max_slots"
      ],
      "properties": {
        "std_optional_fields": {
          "$ref": "BTIDES_base.json#/definitions/std_optional_fields"
        },
        "opcode_str": {
          "description": "This optional field is just for if you don't care about json file size and you want more human-readable JSON output.",
          "type": "string",
          "const": "LMP_MAX_SLOT"
        },
        "opcode": {
          "description": "This should always be 45. This is required to differentiate from other data types in an array.",
          "const": 45
        },
        "max_slots": {
          "description": "1-byte value indicating the number of consecutive slots used by a device on an ACL-U logical link (Spec default is 1.)",
          "type": "integer",
          "minimum": 0,
          "maximum": 255
        }
      }
    },
    "LMP_MAX_SLOT2": {
      "type": "object",
      "description": "Structure for LMP\\_MAX\\_SLOT packet.",
      "required": [
        "opcode",
        "full_pkt_hex_str"
      ],
      "properties": {
        "std_optional_fields": {
          "$ref": "BTIDES_base.json#/definitions/std_optional_fields"
        },
        "opcode_str": {
          "description": "This optional field is just for if you don't care about json file size and you want more human-readable JSON output.",
          "type": "string",
          "const": "LMP_MAX_SLOT"
        },
        "opcode": {
          "description": "This should always be 45. This is required to differentiate from other data types in an array.",
          "const": 45
        },
        "full_pkt_hex_str": {
          "description": "This should *exclude* the opcode byte. Therefore it will always be exactly 1 byte / 2 hex characters.",
          "$ref": "BTIDES_base.json#/definitions/full_pkt_hex_str",
          "minLength": 2,
          "maxLength": 2
        }
      }
    },
    "LMP_MAX_SLOT_REQ": {
      "type": "object",
      "description": "Structure for LMP\\_MAX\\_SLOT\\_REQ packet.",
      "required": [
        "opcode",
        "max_slots"
      ],
      "properties": {
        "std_optional_fields": {
          "$ref": "BTIDES_base.json#/definitions/std_optional_fields"
        },
        "opcode_str": {
          "description": "This optional field is just for if you don't care about json file size and you want more human-readable JSON output.",
          "type": "string",
          "const": "LMP_MAX_SLOT_REQ"
        },
        "opcode": {
          "description": "This should always be 46. This is required to differentiate from other data types in an array.",
          "const": 46
        },
        "max_slots": {
          "description": "1-byte value indicating the number of consecutive slots used by a device on an ACL-U logical link (Spec default is 1.)",
          "type": "integer",
          "minimum": 0,
          "maximum": 255
        }
      }
    },
    "LMP_MAX_SLOT_REQ2": {
      "type": "object",
      "description": "Structure for LMP\\_MAX\\_SLOT\\_REQ packet.",
      "required": [
        "opcode",
        "full_pkt_hex_str"
      ],
      "properties": {
        "std_optional_fields": {
          "$ref": "BTIDES_base.json#/definitions/std_optional_fields"
        },
        "opcode_str": {
          "description": "This optional field is just for if you don't care about json file size and you want more human-readable JSON output.",
          "type": "string",
          "const": "LMP_MAX_SLOT_REQ"
        },
        "opcode": {
          "description": "This should always be 46. This is required to differentiate from other data types in an array.",
          "const": 46
        },
        "full_pkt_hex_str": {
          "description": "This should *exclude* the opcode byte. Therefore it will always be exactly 1 byte / 2 hex characters.",
          "$ref": "BTIDES_base.json#/definitions/full_pkt_hex_str",
          "minLength": 2,
          "maxLength": 2
        }
      }
    },
    "LMP_TIMING_ACCURACY_REQ": {
      "type": "object",
      "description": "Structure for LMP\\_TIMING\\_ACCURACY\\_REQ packet (which is defined as only an opcode, no payload).",
      "required": [
        "opcode"
      ],
      "properties": {
        "std_optional_fields": {
          "$ref": "BTIDES_base.json#/definitions/std_optional_fields"
        },
        "opcode_str": {
          "description": "This optional field is just for if you don't care about json file size and you want more human-readable JSON output.",
          "type": "string",
          "const": "LMP_TIMING_ACCURACY_REQ"
        },
        "opcode": {
          "description": "This should always be 47. This is required to differentiate from other data types in an array.",
          "const": 47
        }
      }
    },
    "LMP_TIMING_ACCURACY_RES": {
      "type": "object",
      "description": "Structure for LMP\\_TIMING\\_ACCURACY\\_RES packet.",
      "required": [
        "opcode",
        "drift",
        "jitter"
      ],
      "properties": {
        "std_optional_fields": {
          "$ref": "BTIDES_base.json#/definitions/std_optional_fields"
        },
        "opcode_str": {
          "description": "This optional field is just for if you don't care about json file size and you want more human-readable JSON output.",
          "type": "string",
          "const": "LMP_TIMING_ACCURACY_RES"
        },
        "opcode": {
          "description": "This should always be 48. This is required to differentiate from other data types in an array.",
          "const": 48
        },
        "drift": {
          "description": "1-byte value indicating the maximum clock drift in clock tick ppm (parts per million). (Spec default is 250.)",
          "type": "integer",
          "minimum": 0,
          "maximum": 255
        },
        "jitter": {
          "description": "1-byte value indicating the maximum jitter in microseconds. (Spec default is 10.)",
          "type": "integer",
          "minimum": 0,
          "maximum": 255
        }
      }
    },
    "LMP_TIMING_ACCURACY_RES2": {
      "type": "object",
      "description": "Structure for LMP\\_TIMING\\_ACCURACY\\_RES packet, as single raw hex string.",
      "required": [
        "opcode",
        "full_pkt_hex_str"
      ],
      "properties": {
        "std_optional_fields": {
          "$ref": "BTIDES_base.json#/definitions/std_optional_fields"
        },
        "opcode_str": {
          "description": "This optional field is just for if you don't care about json file size and you want more human-readable JSON output.",
          "type": "string",
          "const": "LMP_TIMING_ACCURACY_RES"
        },
        "opcode": {
          "description": "This should always be 48. This is required to differentiate from other data types in an array.",
          "const": 48
        },
        "full_pkt_hex_str": {
          "description": "This should *exclude* the opcode byte. Therefore it will always be exactly 2 bytes / 4 hex characters.",
          "$ref": "BTIDES_base.json#/definitions/full_pkt_hex_str",
          "minLength": 4,
          "maxLength": 4
        }
      }
    },
    "LMP_SETUP_COMPLETE": {
      "type": "object",
      "description": "Structure for LMP\\_SETUP\\_COMPLETE packet (which is defined as only an opcode, no payload).",
      "required": [
        "opcode"
      ],
      "properties": {
        "std_optional_fields": {
          "$ref": "BTIDES_base.json#/definitions/std_optional_fields"
        },
        "opcode_str": {
          "description": "This optional field is just for if you don't care about json file size and you want more human-readable JSON output.",
          "type": "string",
          "const": "LMP_SETUP_COMPLETE"
        },
        "opcode": {
          "description": "This should always be 49. This is required to differentiate from other data types in an array.",
          "const": 49
        }
      }
    },
    "LMP_ENCRYPTION_KEY_SIZE_MASK_REQ": {
      "type": "object",
      "description": "Structure for LMP\\_ENCRYPTION\\_KEY\\_SIZE\\_MASK\\_REQ packet (which is defined as only an opcode, no payload).",
      "required": [
        "opcode"
      ],
      "properties": {
        "std_optional_fields": {
          "$ref": "BTIDES_base.json#/definitions/std_optional_fields"
        },
        "opcode_str": {
          "description": "This optional field is just for if you don't care about json file size and you want more human-readable JSON output.",
          "type": "string",
          "const": "LMP_ENCRYPTION_KEY_SIZE_MASK_REQ"
        },
        "opcode": {
          "description": "This should always be 58. This is required to differentiate from other data types in an array.",
          "const": 58
        }
      }
    },
    "LMP_ENCRYPTION_KEY_SIZE_MASK_RES": {
      "type": "object",
      "description": "Structure for LMP\\_ENCRYPTION\\_KEY\\_SIZE\\_MASK\\_RES packet.",
      "required": [
        "opcode",
        "key_size_mask"
      ],
      "properties": {
        "std_optional_fields": {
          "$ref": "BTIDES_base.json#/definitions/std_optional_fields"
        },
        "opcode_str": {
          "description": "This optional field is just for if you don't care about json file size and you want more human-readable JSON output.",
          "type": "string",
          "const": "LMP_ENCRYPTION_KEY_SIZE_MASK_RES"
        },
        "opcode": {
          "description": "This should always be 59. This is required to differentiate from other data types in an array.",
          "const": 59
        },
        "key_size_mask": {
          "description": "2-byte bit field where if bit 0 is set it means key size is not supported, bit 1 means 1 byte key supported, bit 2 means 2 byte key supported, etc. up to bit 16 for 16 byte key supported.",
          "type": "integer",
          "minimum": 0,
          "maximum": 65535
        }
      }
    },
    "LMP_ENCRYPTION_KEY_SIZE_MASK_RES2": {
      "type": "object",
      "description": "Structure for LMP\\_ENCRYPTION\\_KEY\\_SIZE\\_MASK\\_RES packet.",
      "required": [
        "opcode",
        "full_pkt_hex_str"
      ],
      "properties": {
        "std_optional_fields": {
          "$ref": "BTIDES_base.json#/definitions/std_optional_fields"
        },
        "opcode_str": {
          "description": "This optional field is just for if you don't care about json file size and you want more human-readable JSON output.",
          "type": "string",
          "const": "LMP_ENCRYPTION_KEY_SIZE_MASK_RES"
        },
        "opcode": {
          "description": "This should always be 59. This is required to differentiate from other data types in an array.",
          "const": 59
        },
        "full_pkt_hex_str": {
          "description": "This should *exclude* the opcode byte. Therefore it will always be exactly 2 bytes / 4 hex characters.",
          "$ref": "BTIDES_base.json#/definitions/full_pkt_hex_str",
          "minLength": 4,
          "maxLength": 4
        }
      }
    },
    "escape_127": {
      "description": "The 'escape' opcode of 127 (0x7F) that's used at the offset that would normally be the LMP opcode. Used for extended LMP commands (suffixed with _EXT).",
      "type": "integer",
      "const": 127
    },
    "rcvd_escape_opcode": {
      "description": "The 'escape' opcode which was used for the extended LMP command that's being accepted or not accepted.",
      "type": "integer",
      "minimum": 0,
      "maximum": 255
    },
    "rcvd_extended_opcode": {
      "description": "The opcode which was used for the extended LMP command that's being accepted or not accepted.",
      "type": "integer",
      "minimum": 0,
      "maximum": 255
    },
    "rcvd_extended_opcode_str": {
      "description": "Optional string version of the rcvd_extended_opcode (e.g. like 'LMP\\_ACCEPTED\\_EXT').",
      "type": "string",
      "maximum": 33
    },
    "LMP_ACCEPTED_EXT": {
      "type": "object",
      "description": "Structure for LMP\\_ACCEPTED\\_EXT packet.",
      "required": [
        "escape_127",
        "extended_opcode",
        "rcvd_escape_opcode",
        "rcvd_extended_opcode"
      ],
      "properties": {
        "std_optional_fields": {
          "$ref": "BTIDES_base.json#/definitions/std_optional_fields"
        },
        "escape_127": {
          "$ref": "#/definitions/escape_127"
        },
        "extended_opcode": {
          "description": "This should always be 1. This is required to differentiate from other data types in an array.",
          "const": 1
        },
        "extended_opcode_str": {
          "description": "This optional field is just for if you don't care about json file size and you want more human-readable JSON output.",
          "type": "string",
          "const": "LMP_ACCEPTED_EXT"
        },
        "rcvd_escape_opcode": {
          "$ref": "#/definitions/rcvd_escape_opcode"
        },
        "rcvd_extended_opcode": {
          "$ref": "#/definitions/rcvd_extended_opcode"
        },
        "rcvd_extended_opcode_str": {
          "$ref": "#/definitions/rcvd_extended_opcode_str"
        }
      }
    },
    "LMP_ACCEPTED_EXT2": {
      "type": "object",
      "description": "Structure for LMP\\_ACCEPTED\\_EXT packet, as single raw hex string.",
      "required": [
        "escape_127",
        "extended_opcode",
        "full_pkt_hex_str"
      ],
      "properties": {
        "std_optional_fields": {
          "$ref": "BTIDES_base.json#/definitions/std_optional_fields"
        },
        "escape_127": {
          "$ref": "#/definitions/escape_127"
        },
        "extended_opcode": {
          "description": "This should always be 1. This is required to differentiate from other data types in an array.",
          "const": 1
        },
        "extended_opcode_str": {
          "description": "This optional field is just for if you don't care about json file size and you want more human-readable JSON output.",
          "type": "string",
          "const": "LMP_ACCEPTED_EXT"
        },
        "full_pkt_hex_str": {
          "description": "This should *exclude* the opcode byte. Therefore it will always be exactly 2 bytes / 4 hex characters.",
          "$ref": "BTIDES_base.json#/definitions/full_pkt_hex_str",
          "minLength": 4,
          "maxLength": 4
        }
      }
    },
    "LMP_NOT_ACCEPTED_EXT": {
      "type": "object",
      "description": "Structure for LMP\\_NOT\\_ACCEPTED\\_EXT packet.",
      "required": [
        "escape_127",
        "extended_opcode",
        "rcvd_escape_opcode",
        "rcvd_extended_opcode",
        "error_code"
      ],
      "properties": {
        "std_optional_fields": {
          "$ref": "BTIDES_base.json#/definitions/std_optional_fields"
        },
        "escape_127": {
          "$ref": "#/definitions/escape_127"
        },
        "extended_opcode": {
          "description": "This should always be 2. This is required to differentiate from other data types in an array.",
          "const": 2
        },
        "extended_opcode_str": {
          "description": "This optional field is just for if you don't care about json file size and you want more human-readable JSON output.",
          "type": "string",
          "const": "LMP_NOT_ACCEPTED_EXT"
        },
        "rcvd_escape_opcode": {
          "$ref": "#/definitions/rcvd_escape_opcode"
        },
        "rcvd_extended_opcode": {
          "$ref": "#/definitions/rcvd_extended_opcode"
        },
        "rcvd_extended_opcode_str": {
          "$ref": "#/definitions/rcvd_extended_opcode_str"
        },
        "error_code": {
          "$ref": "#/definitions/error_code"
        },
        "error_code_str": {
          "$ref": "#/definitions/error_code_str"
        }
      }
    },
    "LMP_NOT_ACCEPTED_EXT2": {
      "type": "object",
      "description": "Structure for LMP\\_NOT\\_ACCEPTED\\_EXT packet, as single raw hex string.",
      "required": [
        "escape_127",
        "extended_opcode",
        "full_pkt_hex_str"
      ],
      "properties": {
        "std_optional_fields": {
          "$ref": "BTIDES_base.json#/definitions/std_optional_fields"
        },
        "escape_127": {
          "$ref": "#/definitions/escape_127"
        },
        "extended_opcode": {
          "description": "This should always be 2. This is required to differentiate from other data types in an array.",
          "const": 2
        },
        "extended_opcode_str": {
          "description": "This optional field is just for if you don't care about json file size and you want more human-readable JSON output.",
          "type": "string",
          "const": "LMP_NOT_ACCEPTED_EXT"
        },
        "full_pkt_hex_str": {
          "description": "This should *exclude* the opcode byte. Therefore it will always be exactly 3 bytes / 6 hex characters.",
          "$ref": "BTIDES_base.json#/definitions/full_pkt_hex_str",
          "minLength": 6,
          "maxLength": 6
        }
      }
    },
    "LMP_FEATURES_REQ_EXT": {
      "type": "object",
      "description": "Structure for LMP\\_FEATURES\\_REQ\\_EXT packet.",
      "required": [
        "escape_127",
        "extended_opcode",
        "page",
        "max_page",
        "lmp_features_hex_str"
      ],
      "properties": {
        "std_optional_fields": {
          "$ref": "BTIDES_base.json#/definitions/std_optional_fields"
        },
        "escape_127": {
          "$ref": "#/definitions/escape_127"
        },
        "extended_opcode": {
          "description": "This should always be 3. This is required to differentiate from other data types in an array.",
          "const": 3
        },
        "extended_opcode_str": {
          "description": "This optional field is just for if you don't care about json file size and you want more human-readable JSON output.",
          "type": "string",
          "const": "LMP_FEATURES_REQ_EXT"
        },
        "page": {
          "description": "Which page of features this corresponds to.",
          "type": "integer"
        },
        "max_page": {
          "description": "The maximum supported page (64-bit chunk) which contains non-zero features.",
          "type": "integer"
        },
        "lmp_features_hex_str": {
          "$ref": "#/definitions/lmp_features_hex_str"
        }
      }
    },
    "LMP_FEATURES_REQ_EXT2": {
      "type": "object",
      "description": "Structure for LMP\\_FEATURES\\_REQ\\_EXT packet, as single raw hex string..",
      "required": [
        "escape_127",
        "extended_opcode",
        "full_pkt_hex_str"
      ],
      "properties": {
        "std_optional_fields": {
          "$ref": "BTIDES_base.json#/definitions/std_optional_fields"
        },
        "escape_127": {
          "$ref": "#/definitions/escape_127"
        },
        "extended_opcode": {
          "description": "This should always be 3. This is required to differentiate from other data types in an array.",
          "const": 3
        },
        "extended_opcode_str": {
          "description": "This optional field is just for if you don't care about json file size and you want more human-readable JSON output.",
          "type": "string",
          "const": "LMP_FEATURES_REQ_EXT"
        },
        "full_pkt_hex_str": {
          "description": "This should *exclude* the escape byte and opcode byte. Therefore it will always be exactly 10 bytes / 20 hex characters.",
          "$ref": "BTIDES_base.json#/definitions/full_pkt_hex_str",
          "minLength": 20,
          "maxLength": 20
        }
      }
    },
    "LMP_FEATURES_RES_EXT": {
      "type": "object",
      "description": "Structure for LMP\\_FEATURES\\_RES\\_EXT packet.",
      "required": [
        "escape_127",
        "extended_opcode",
        "page",
        "max_page",
        "lmp_features_hex_str"
      ],
      "properties": {
        "std_optional_fields": {
          "$ref": "BTIDES_base.json#/definitions/std_optional_fields"
        },
        "escape_127": {
          "$ref": "#/definitions/escape_127"
        },
        "extended_opcode": {
          "description": "This should always be 4. This is required to differentiate from other data types in an array.",
          "const": 4
        },
        "extended_opcode_str": {
          "description": "This optional field is just for if you don't care about json file size and you want more human-readable JSON output.",
          "type": "string",
          "const": "LMP_FEATURES_RES_EXT"
        },
        "page": {
          "description": "Which page of features this corresponds to.",
          "type": "integer"
        },
        "max_page": {
          "description": "The maximum supported page (64-bit chunk) which contains non-zero features.",
          "type": "integer"
        },
        "lmp_features_hex_str": {
          "$ref": "#/definitions/lmp_features_hex_str"
        }
      }
    },
    "LMP_FEATURES_RES_EXT2": {
      "type": "object",
      "description": "Structure for LMP\\_FEATURES\\_RES\\_EXT packet, as single raw hex string..",
      "required": [
        "escape_127",
        "extended_opcode",
        "full_pkt_hex_str"
      ],
      "properties": {
        "std_optional_fields": {
          "$ref": "BTIDES_base.json#/definitions/std_optional_fields"
        },
        "escape_127": {
          "$ref": "#/definitions/escape_127"
        },
        "extended_opcode": {
          "description": "This should always be 4. This is required to differentiate from other data types in an array.",
          "const": 4
        },
        "extended_opcode_str": {
          "description": "This optional field is just for if you don't care about json file size and you want more human-readable JSON output.",
          "type": "string",
          "const": "LMP_FEATURES_RES_EXT"
        },
        "full_pkt_hex_str": {
          "description": "This should *exclude* the escape byte and opcode byte. Therefore it will always be exactly 10 bytes / 20 hex characters.",
          "$ref": "BTIDES_base.json#/definitions/full_pkt_hex_str",
          "minLength": 20,
          "maxLength": 20
        }
      }
    },
    "LMP_CHANNEL_CLASSIFICATION": {
      "type": "object",
      "description": "Structure for LMP\\_CHANNEL\\_CLASSIFICATION packet.",
      "required": [
        "escape_127",
        "extended_opcode",
        "afh_channel_classification_hex_str"
      ],
      "properties": {
        "std_optional_fields": {
          "$ref": "BTIDES_base.json#/definitions/std_optional_fields"
        },
        "escape_127": {
          "$ref": "#/definitions/escape_127"
        },
        "extended_opcode": {
          "description": "This should always be 17. This is required to differentiate from other data types in an array.",
          "const": 17
        },
        "extended_opcode_str": {
          "description": "This optional field is just for if you don't care about json file size and you want more human-readable JSON output.",
          "type": "string",
          "const": "LMP_CHANNEL_CLASSIFICATION"
        },
        "afh_channel_classification_hex_str": {
          "description": "10-byte value (2 bit classifier * 40 channels) as hex string.",
          "type": "string",
          "minLength": 20,
          "maxLength": 20
        }
      }
    },
    "LMP_CHANNEL_CLASSIFICATION2": {
      "type": "object",
      "description": "Structure for LMP\\_CHANNEL\\_CLASSIFICATION packet, as single raw hex string..",
      "required": [
        "escape_127",
        "extended_opcode",
        "full_pkt_hex_str"
      ],
      "properties": {
        "std_optional_fields": {
          "$ref": "BTIDES_base.json#/definitions/std_optional_fields"
        },
        "escape_127": {
          "$ref": "#/definitions/escape_127"
        },
        "extended_opcode": {
          "description": "This should always be 17. This is required to differentiate from other data types in an array.",
          "const": 17
        },
        "extended_opcode_str": {
          "description": "This optional field is just for if you don't care about json file size and you want more human-readable JSON output.",
          "type": "string",
          "const": "LMP_CHANNEL_CLASSIFICATION"
        },
        "full_pkt_hex_str": {
          "description": "This should *exclude* the escape byte and opcode byte. Therefore it will always be exactly 10 bytes / 20 hex characters.",
          "$ref": "BTIDES_base.json#/definitions/full_pkt_hex_str",
          "minLength": 20,
          "maxLength": 20
        }
      }
    },
    "LMP_POWER_CONTROL_REQ": {
      "type": "object",
      "description": "Structure for LMP\\_POWER\\_CONTROL\\_REQ packet.",
      "required": [
        "escape_127",
        "extended_opcode",
        "power_adj_req"
      ],
      "properties": {
        "std_optional_fields": {
          "$ref": "BTIDES_base.json#/definitions/std_optional_fields"
        },
        "escape_127": {
          "$ref": "#/definitions/escape_127"
        },
        "extended_opcode": {
          "description": "This should always be 31. This is required to differentiate from other data types in an array.",
          "const": 31
        },
        "extended_opcode_str": {
          "description": "This optional field is just for if you don't care about json file size and you want more human-readable JSON output.",
          "type": "string",
          "const": "LMP_POWER_CONTROL_REQ"
        },
        "power_adj_req": {
          "description": "Request to increment, decrement, or increase to maximu the transmit power level.",
          "type": "integer",
          "minimum": 0,
          "maximum": 255
        }
      }
    },
    "LMP_POWER_CONTROL_REQ2": {
      "type": "object",
      "description": "Structure for LMP\\_POWER\\_CONTROL\\_REQ packet, as single raw hex string..",
      "required": [
        "escape_127",
        "extended_opcode",
        "full_pkt_hex_str"
      ],
      "properties": {
        "std_optional_fields": {
          "$ref": "BTIDES_base.json#/definitions/std_optional_fields"
        },
        "escape_127": {
          "$ref": "#/definitions/escape_127"
        },
        "extended_opcode": {
          "description": "This should always be 31. This is required to differentiate from other data types in an array.",
          "const": 31
        },
        "extended_opcode_str": {
          "description": "This optional field is just for if you don't care about json file size and you want more human-readable JSON output.",
          "type": "string",
          "const": "LMP_POWER_CONTROL_REQ"
        },
        "full_pkt_hex_str": {
          "description": "This should *exclude* the escape byte and opcode byte. Therefore it will always be exactly 1 byte / 2 hex characters.",
          "$ref": "BTIDES_base.json#/definitions/full_pkt_hex_str",
          "minLength": 2,
          "maxLength": 2
        }
      }
    },
    "LMP_POWER_CONTROL_RES": {
      "type": "object",
      "description": "Structure for LMP\\_POWER\\_CONTROL\\_RES packet.",
      "required": [
        "escape_127",
        "extended_opcode",
        "power_adj_res"
      ],
      "properties": {
        "std_optional_fields": {
          "$ref": "BTIDES_base.json#/definitions/std_optional_fields"
        },
        "escape_127": {
          "$ref": "#/definitions/escape_127"
        },
        "extended_opcode": {
          "description": "This should always be 32. This is required to differentiate from other data types in an array.",
          "const": 32
        },
        "extended_opcode_str": {
          "description": "This optional field is just for if you don't care about json file size and you want more human-readable JSON output.",
          "type": "string",
          "const": "LMP_POWER_CONTROL_RES"
        },
        "power_adj_res": {
          "description": "Array of 4 2-bit values, for GFSK, /4-DQPSK, 8DPSK & reserved, indicating whether to change the TX power by 1 step or move to min or max power.",
          "type": "integer",
          "minimum": 0,
          "maximum": 255
        }
      }
    },
    "LMP_POWER_CONTROL_RES2": {
      "type": "object",
      "description": "Structure for LMP\\_POWER\\_CONTROL\\_RES packet, as single raw hex string..",
      "required": [
        "escape_127",
        "extended_opcode",
        "full_pkt_hex_str"
      ],
      "properties": {
        "std_optional_fields": {
          "$ref": "BTIDES_base.json#/definitions/std_optional_fields"
        },
        "escape_127": {
          "$ref": "#/definitions/escape_127"
        },
        "extended_opcode": {
          "description": "This should always be 32. This is required to differentiate from other data types in an array.",
          "const": 32
        },
        "extended_opcode_str": {
          "description": "This optional field is just for if you don't care about json file size and you want more human-readable JSON output.",
          "type": "string",
          "const": "LMP_POWER_CONTROL_RES"
        },
        "full_pkt_hex_str": {
          "description": "This should *exclude* the escape byte and opcode byte. Therefore it will always be exactly 1 byte / 2 hex characters.",
          "$ref": "BTIDES_base.json#/definitions/full_pkt_hex_str",
          "minLength": 2,
          "maxLength": 2
        }
      }
    }
  }
}